#summary Mathematical issues that could improve the diagrams
#labels Phase-Requirements

The basic idea to draw thread diagrams is drawing small curved segments of lines. A shadow for each segment creates the over/under effect. A shadow with a colour identical to the background creates the traditional diagrams:

[http://bobbinwork.googlecode.com/svn/wiki/images/bezier/shadow.PNG]

<wiki:toc max_depth="3" />

= Shortened ends =
Unlike traditional diagrams, the diagram above shows no ends come out of the stitch going to the bobbins. That is a technical work-around for better chaining the stitches together. If the chaining can not be improved, such that it can deal with overlapping ends, the program should extend the loose ends for a while. This is rather a programming challenge than a mathematical challenge, though it might be tricky in what direction to extend the loose ends.

= Gaps =
The following code snippet shows how to define the Bezier curves of a half stitch. Note that the "." is for the decimals and the "," separates X from Y. X being the horizontal distance from the left side of the canvas, and Y the vertical distance from the top side of the canvas, so 0,0 is the top left corner.
{{{
<stitch id="tc" pairs="15-16">
    <pair start="3,13.3" end="13.5,3" />
    <pair start="3,3" end="13.5,13.5" />
    <twist bobbins="1-2">
        <back start="0,6.6" end="5,11.6" />
        <front start="5,2" c1="5,5" c2="5,5" end="0,10" />
    </twist>
    <twist bobbins="3-4">
        <back start="11.6,2" c1="11.6,5" c2="11.6,5" end="16.6,10" />
        <front start="16.6,6.6" end="11.6,11.6" />
    </twist>
    <cross bobbins="2-3">
        <back start="11.6,11.6" end="6.6,16.6" />
        <front start="5,11.6" end="10,16.3" />
    </cross>
</stitch>
}}}

[http://bobbinwork.googlecode.com/svn/wiki/images/bezier/ttc.PNG]

Combining two of such twists and a cross, would result in the left diagram. The right versions shows what happens when the program knows how to make the ends meet. But just making the ends meet is not sufficient. The "shadow" still shows a gap. 

[http://bobbinwork.googlecode.com/svn/wiki/images/bezier/basics.PNG]

As shown in the picture above, not only the black end and red start should be on the same spot, but they should also be on a straight line with black c2 and red c1. That might be a smaller challenge than extending the ends discussed above. But it adds to the tension challenge discussed below.

= Tension =
In this example of a striped Vierge ground, the drunken coloured lines show that the program doesn't know how to tension the threads.

[http://bobbinwork.googlecode.com/svn/wiki/images/bezier/drunken.PNG]

After making the segment ends meet and put the control points in a straight line as described above. Subsequently the line/thread should be flattened/tensioned. This flattening process has some restrictions:

 * threads cannot move through pins
 * segments within a "switch" should stay together: an X should not turn into a T or even separated, where the width of the shadow and angle determines when an X turns into a T.

On a pair level flattening lines is less an issue but when an X turns into a T is not so well defined.

= Highlighting threads =

Selecting threads has an obvious bug. The current strategy is drizzling into the details of the tree until the cross or twist is found that contains the mouse pointer. Then nearest thread is highlighted. The following issue show why some sections at the edge sometimes can't be selected.

= Highlighting (groups of) stitches =

[http://bobbinwork.googlecode.com/svn/wiki/images/bezier/high-lights.PNG]

In the Image above, the yellow area is the bounding polygon of a group of stitches, used to highlight them. The green dots show the start points and end points of the selected group of stitches that define the polygon. That is a quick and dirty solution. It usually works when just drawing grounds. But the red curve at the left of this highlight should also be included. Multiple foot side stitches along a curve would be even worse. So here has to change something too.

The Connectors class looses information about internal segments.
We should also merge the bounding polygons of the children 
and store the result with the parent. 
Using polygons is more complex than rectangular bounding boxes, but rectangles would cause overlap.
We can't use overlap when drizzling down the tree to find which thread is pointed at. 

http://code.google.com/p/bobbinwork/source/browse/trunk/src/nl/BobbinWork/diagram/model/Connectors.java?r=244
implements an improvement at stitch level. It tries to use control points too, this needs the following changes:
<pre>
addPoint(*b.getStart(), a.getEnd()*,rights,b.getC1());
addPoint(*b.getStart(), a.getEnd()*,rights,a.getC2());
addPoint(*b.getEnd(), a.getStart()*,lefts,b.getC2());
addPoint(*b.getEnd(), a.getStart()*,lefts,a.getC1());
...
/`*``*` Adds east to list if the compas is only rotated and not mirrored. `*`/
private void addPoint(*Point north, Point south*, List<Point> list, Point *east*){
</pre>

=Question=

How to implement the following isMirrored?

<pre>
import java.awt.geom.Point2D;
public class Compas {
  private static boolean isMirrored(
       Point2D north, 
       Point2D east, 
       Point2D south)
  {
     return false;
  }
  public static void main (String[] args) {
    Point2D[][] ps = { 
      // (0,0) is north-west corner of canvas, compass may be rotated
      {new Point2D.Float(1,0),new Point2D.Float(1,2),new Point2D.Float(2,1)},//false
      {new Point2D.Float(1,1),new Point2D.Float(1,2),new Point2D.Float(0,1)},//true
    };
    for ( Point2D[] p:ps ) {
      System.out.println(isMirrored(p[0],p[1],p[2]));
    }
  }
}
</pre>

Rotate east and and south together around north and return (rotatedEast.x < north.x) ?

Calculate a line through east perpendicular on north-south and do something with the direction of both lines?

Would java.awt.geom.AffineTransform and/or java.awt.Graphics2D be useful?